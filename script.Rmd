---
title             : "Cognitive correlates of mental health in adolescence: A network analysis approach"
shorttitle        : "Combined Cognitive Bias Hypothesis Network"

author: 
  - name          : "Sam Parsons"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "Postal address"
    email         : "sam.parsons@psy.ox.ac.uk"
  - name          : "Annabel Songco"
    affiliation   : "1"
  - name          : "Charlotte Booth"
    affiliation   : "1"
  - name          : "Elaine Fox"
    affiliation   : "1"

affiliation:
  - id            : "1"
    institution   : "University of Oxford"


authornote: |
  Add complete departmental affiliations for each author here. Each new line herein must be indented, like this line.

  Enter author note here.

abstract: |
  This is my abstract
  
keywords          : "keywords"
wordcount         : "X"

bibliography      : ["r-references.bib"]

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : yes
mask              : no
draft             : no

documentclass     : "apa6"
classoption       : "man"
output            : papaja::apa6_pdf

header-includes: #allows you to add in your own Latex packages
- \usepackage{float} #use the 'float' package
- \floatplacement{figure}{H} #make every figure with caption = h
- \raggedbottom

---
```{r setup}
# comment in as needed
knitr::opts_chunk$set(comment = NA)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.pos= "h")
knitr::opts_chunk$set(tidy = TRUE)
knitr::opts_chunk$set(results='hide')


```

```{r load_packages, include = FALSE}
library("papaja")    # for APA formatting awesome-ness in Rmarkdown
library("tidyverse") # for restructuring data
library("foreign")   # for using SPSS data
library("bootnet")   # for network analysis
library("mgm")       # for networtk analysis
library("qgraph")    # for network analysis - specifically averageLayout
library("NetworkComparisonTest") # for network model comparisons
library("parallel") # used to get number of cores for bootnet

```

```{r load_data}
# demographics, questionnaire responses, and task data all stored in separate SPSS data files.
demographics <- read.spss("Data/W1_demographics.sav", to.data.frame = TRUE)
# scores1 <- read.spss("Data/W1_Q1.sav", to.data.frame = TRUE)
scores2 <- read.spss("Data/W1_Q2.sav", to.data.frame = TRUE)
AIBQ <- read.spss("Data/W1_AIBQ.sav", to.data.frame = TRUE)
Memory <- read.spss("Data/W1_SRET.sav", to.data.frame = TRUE)
```


```{r create dataframe for analysis}
# first extract the variables of interest
Qdat <- data.frame(subject = scores2$Master_subject,
                   MHC_Tot = scores2$MCSHC_Total)

AIBQdat <- data.frame(subjectAIBQ = AIBQ$Master_subject,
                      Pos_Soc    = AIBQ$Interpretation_Pos_Social,
                      Pos_nonsoc = AIBQ$Interpretation_Pos_Nonsocial,
                      Neg_soc    = AIBQ$Interpretation_Neg_Social,
                      Neg_nonsoc = AIBQ$Interpretation_Neg_Nonsocial)

Memdat <- data.frame(subjectMEM = Memory$Master_subject,
                     MEM_pos = Memory$PosEndorsedAndRecalled,
                     MEM_neg = Memory$NegEndorsedAndRecalled)

# combine into one dataframe
CCBH <- cbind(Qdat,AIBQdat,Memdat)

# quick checks that all IDs match
sum(isFALSE(CCBH$subject == CCBH$subjectAIBQ)) 
sum(isFALSE(CCBH$subjectQ == CCBH$subjectMEM))
sum(isFALSE(CCBH$subjectAIBQ == CCBH$subjectMEM))

# remove previous data frames to save space
remove(list = c("AIBQ", "Memory", "Qdat","AIBQdat", "Memdat"))

# remove participants with incomplete data # n=443 (with that extra participant, and DPT acc < 70% removed)
CCBH <- na.omit(CCBH)

mean(CCBH$MHC_Tot)
sd(CCBH$MHC_Tot)
quantile(CCBH$MHC_Tot, c(.33, .66)) # 37 and 47

```

```{r create high and low groups}
# checking sample size for the tertile split
low  <- sum(CCBH$MHC_Tot < 37) # 145
mid  <- sum(CCBH$MHC_Tot >= 37 & CCBH$MHC_Tot <= 47) # 153
high <- sum(CCBH$MHC_Tot > 47) # 150

# subsetting into three samples
low2 <- subset(CCBH, MHC_Tot < 37) # 
mid2 <- subset(CCBH, MHC_Tot >= 37 & MHC_Tot <= 47)
high2 <- subset(CCBH, MHC_Tot > 47)

low_ppt <- unique(low2$subject)
mid_ppt <- unique(mid2$subject)
high_ppt <- unique(high2$subject)


# selecting only the variables for inclusion in the networks
low3  <- low2[,c(4,5,6,7,9,10)]
mid3  <- mid2[,c(4,5,6,7,9,10)]
high3 <- high2[,c(4,5,6,7,9,10)]

# changing variable names for interpretability
variable_names  <- c("IB_S_Pos", "IB_N_Pos", "IB_S_Neg", "IB_N_Neg", "MB_Pos", "MB_Neg")
colnames(low3)  <- variable_names
colnames(mid3)  <- variable_names
colnames(high3) <- variable_names

```

Background:

The data are drawn from the CogBIAS longitudinal study (wave 1 only). Analysed are the DVs from the interpretation bias task, memory bias task, and mental health questionnaire. 



## Comparing groups high and low in positive mental health

Figure 1 presents regularised partial correlations amongst interpretation and memory biases. 


```{r glasso networks, results = 'hide', fig.show="hide"}
# estimate the networks
glasso_low  <- estimateNetwork(low3, default = "EBICglasso", tuning = .5)
glasso_mid  <- estimateNetwork(mid3, default = "EBICglasso", tuning = .5)
glasso_high  <- estimateNetwork(high3, default = "EBICglasso", tuning = .5)

low_glas_weights <- glasso_low$graph
colnames(low_glas_weights) <- variable_names
rownames(low_glas_weights) <- variable_names
mid_glas_weights <- glasso_mid$graph
colnames(mid_glas_weights) <- variable_names
rownames(mid_glas_weights) <- variable_names
high_glas_weights <- glasso_high$graph
colnames(high_glas_weights) <- variable_names
rownames(high_glas_weights) <- variable_names


max_glass <- max(low_glas_weights[which(low_glas_weights != 1)], mid_glas_weights[which(mid_glas_weights != 1)], high_glas_weights[which(high_glas_weights != 1)]) # returns highest weight in the three samples' correlation matrices


write.csv(low_glas_weights, "./Apendices/low_glasso_weights.csv")
write.csv(mid_glas_weights, "./Apendices/mid_glasso_weights.csv")
write.csv(high_glas_weights, "./Apendices/high_glasso_weights.csv")

# plot the three networks
layout_common <- averageLayout(glasso_low,glasso_mid,glasso_high) # this is now the common layout for each figure

layout(t(1:3))
plot(glasso_low, layout = layout_common, title = "low - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_mid, layout = layout_common, title = "mid - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

# look at the global density
sum(abs(glasso_low$graph))/2
sum(abs(glasso_mid$graph))/2
sum(abs(glasso_high$graph))/2

# plot the low and high sample networks
layout(t(1:2))
plot(glasso_low, layout = layout_common, title = "low - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

# save this plot

Cairo::Cairo(file="Figures/twoglasso.png", 
      type="png",
      bg = "white",
      units="in", 
      width=16, 
      height=8, 
      pointsize=12, 
      dpi=144)
layout(t(1:2))

plot(glasso_low, layout = layout_common, title = "low - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

dev.off()


```

```{r plotting_highlow}

layout(t(1:2))

plot(glasso_low, layout = layout_common, title = "low - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

```

### network comparisons

```{r networkcomparisontest, results='hide'}
lh <- NCT(low3[,1:6], high3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
lm <- NCT(low3[,1:6], mid3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
mh <- NCT(mid3[,1:6], high3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
```

```{r}
lh$glstrinv.pval
lh$nwinv.pval

lm$glstrinv.pval
lm$nwinv.pval

mh$glstrinv.pval
mh$nwinv.pval
```

We compared the estimated networks using NetworkComparisonTest with 1000 iterations. Global strength in the high MH group (`r sum(abs(glasso_high$graph))/2`) differed from that in the low MH group (`r sum(abs(glasso_low$graph))/2`), _p_ = `r printp(lh$glstrinv.pval)`. There was no significant difference between global strength in the low MH group and the mid MH group (`r sum(abs(glasso_mid$graph))/2`), _p_ = `r printp(lm$glstrinv.pval)`; nor between the mid MH and high MH groups, _p_ = `r printp(mh$glstrinv.pval)`.

\newpage


```{r trying to figure out optimalgraph, eval=FALSE}

modSelect_0 <- ggmModSelect(cor_auto(low3), nrow(low3), nCores = 12, start = "glasso", considerPerStep = "all", gamma = 0)

qgraph(modSelect_0$graph, layout = "spring", theme = "colorblind", 
       title = "ggmModSelect (gamma = 0)", cut = 0)

modSelect_0.5 <- ggmModSelect(cor_auto(low3), nrow(low3), gamma = 0.5, nCores = 12, start = "glasso", considerPerStep = "all")

qgraph(modSelect_0.5$graph, layout = "spring", theme = "colorblind", 
       title = "ggmModSelect (gamma = 0)", cut = 0)

```

## Including Mental Health in the model

We explored the difference in models between high and low groups using the mgm package. Figure 2 presents the network including mental health as a categorical variable (only for high and low MH groups). 

Note. the shaded area of the 'pie' is the predicability of that node, i.e. the variance explained in that variable by the rest of the network. (I also need to include a more detailed explanation of why MH is different here as a categorical variable).

```{r mgm, results='hide'}
# this block includes MH as a categorical variable and includes it in mgm, also returns predictability indices. 

# put low and high group into a single dataframe
low3$MH <- 0
high3$MH <- 1

full <- rbind(low3, high3)

fit_obj <- mgm(data = full,
  type = c(rep("g", 6), "c"),
  level = c(rep(1, 6), 2),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE)



p_obj <- predict(fit_obj, full,
errorCat = c("CC","nCC","CCmarg"),
errorCon = c("R2"))


error_list <- list() # List for ring-segments
for(i in 1:6) error_list[[i]] <- p_obj$errors[i,2]
beyondmarg <- p_obj$errors[7,3]-p_obj$errors[7,5]
error_list[[7]] <- c(p_obj$errors[7,5],beyondmarg)

color_list <- list() # List for Colors
for(i in 1:6) color_list[[i]] <- "#90B4D4"
color_list[[7]] <- c("#ffa500", "#ff4300")

qgraph(fit_obj$pairwise$wadj, pie = error_list,
  layout="spring", labels = colnames(full),
  pieColor = color_list, label.cex = .9,
  edge.color = fit_obj$pairwise$edgecolor,
  curveAll = TRUE, curveDefault = .6,
  cut = 0, labels = col(full))
```

## we then set mental health to be a moderator of the network

```{r, results='hide', fig.show = "hide"}
fit_obj2 <- mgm(data = full,
  type = c(rep("g", 6), "c"),
  level = c(rep(1, 6), 2),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(7),
  lambdaFolds = 10,
  alphaFolds = 10
  #,
  #lambdaSel = "EBIC",   #possible alternatives
  #lambdaGam = .25
)

# n interactions
n_int <- length(fit_obj2$interactions$weightsAgg[[2]])

# for the predictability aspect
p_obj2 <- predict(fit_obj2, full,
errorCat = c("CC","nCC","CCmarg"),
errorCon = c("R2"))


error_list2 <- list() # List for ring-segments
for(i in 1:6) error_list2[[i]] <- p_obj2$errors[i,2]
beyondmarg2 <- p_obj2$errors[7,3]-p_obj2$errors[7,5]
error_list2[[7]] <- c(p_obj2$errors[7,5],beyondmarg2)

color_list2 <- list() # List for Colors
for(i in 1:6) color_list2[[i]] <- "#90B4D4"
color_list2[[7]] <- c("#ffa500", "#ff4300")

# plotting predictability
qgraph(fit_obj2$pairwise$wadj, pie = error_list2,
  layout="spring", labels = colnames(full),
  pieColor = color_list2, label.cex = .9,
  edge.color = fit_obj2$pairwise$edgecolor,
  curveAll = TRUE, curveDefault = .6,
  cut = 0, labels = col(full))

# plotting the interactions
FactorGraph(object = fit_obj2,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(full),
title = "fit2 with interactions")


# #playing
# FactorGraph(object = fit_obj2,
# edge.labels = FALSE,
# PairwiseAsEdge = TRUE,
# FactorLabels = TRUE,
# Nodewise = TRUE, 
# labels = colnames(full))

# plotting the interactions and the predictability
img <- FactorGraph(object = fit_obj2,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(full),
pie = c(error_list2, rep(0,n_int)),
pieBorder = c(rep(.2,7),rep(0,n_int)),
pieColor = c(color_list2,rep(0,n_int)))

# could add these for prettiness
#vsize = 2,
#vsize2 = .5,
#label.cex = 1,
#repulsion = .63)


# quick save

Cairo::Cairo(file="Figures/mgmtest.png", 
      type="png",
      bg = "white",
      units="in", 
      width=16, 
      height=8, 
      pointsize=12, 
      dpi=144)

FactorGraph(object = fit_obj2,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(full),
pie = c(error_list2, rep(0,n_int)),
pieBorder = c(rep(.2,7),rep(0,n_int)),
pieColor = c(color_list2,rep(0,n_int)),
vsize = 2,
vsize2 = .5,
label.cex = 1,
repulsion = .63)

dev.off()


```

```{r }
FactorGraph(object = fit_obj2,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(full),
pie = c(error_list2, rep(0,n_int)),
pieBorder = c(rep(.2,7),rep(0,n_int)),
pieColor = c(color_list2,rep(0,n_int)),
title = "MH as a categorical variable in the model")

```


The square nodes link to three nodes. First, they each link to MH as the moderating variable. The two other nodes linked to indicate the edge that is moderated by the MH variable, e.g. the relationship between Positive and Negative memory biases. 


```{r checknumberofmoderatededges, eval = FALSE}

mod_list <- rep(1, 50)
count <- 1

for(i in 1:50) {

fit_obj2 <- mgm(data = full,
  type = c(rep("g", 6), "c"),
  level = c(rep(1, 6), 2),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(7),
  lambdaFolds = 50,
  alphaFolds = 50
  #,
  #lambdaSel = "EBIC",   #possible alternatives
  #lambdaGam = .25
)

# n interactions
mod_list[i] <- length(fit_obj2$interactions$weightsAgg[[2]])

count <- count + 1
}
mean(mod_list)
min(mod_list)
max(mod_list)


```


## we followed this by using MH as a linear moderator, and included the full sample


```{r, results='hide', fig.show="hide"}
# does it work for linear moderators????

testing <- CCBH %>%
  select(2,4,5,6,7,9,10) %>%
  rename(MH = MHC_Tot,
         IB_S_Pos = Pos_Soc,
         IB_N_Pos = Pos_nonsoc,
         IB_S_Neg = Neg_soc,
         IB_N_Neg = Neg_nonsoc,
         MB_Pos = MEM_pos,
         MB_Neg = MEM_neg)
  

fit_obj3 <- mgm(data = testing,
  type = c(rep("g", 7)),
  level = c(rep(1, 7)),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(1)#,
  #lambdaSel = "EBIC",
  #lambdaGam = .5
)

# n interactions
n_int3 <- length(fit_obj3$interactions$weightsAgg[[2]])

# for the predictability aspect
p_obj3 <- predict(fit_obj3, testing,
errorCat = c("CC","nCC","CCmarg"),
errorCon = c("R2"))


error_list3 <- list() # List for ring-segments
for(i in 1:7) error_list3[[i]] <- p_obj3$errors[i,2]
#beyondmarg <- p_obj2$errors[10,3]-p_obj2$errors[10,5]
#error_list[[10]] <- c(p_obj2$errors[10,5],beyondmarg)

color_list3 <- list() # List for Colors
for(i in 1:7) color_list3[[i]] <- "#90B4D4"
#color_list[[10]] <- c("#ffa500", "#ff4300")

# plotting predictability
qgraph(fit_obj3$pairwise$wadj, pie = error_list3,
  layout="spring", labels = colnames(testing),
  pieColor = color_list3, label.cex = .9,
  edge.color = fit_obj3$pairwise$edgecolor,
  curveAll = TRUE, curveDefault = .6,
  cut = 0, labels = colnames(testing))

# plotting the interactions
FactorGraph(object = fit_obj3,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(testing),
title = "full sample - mental health as a linear moderator")




 ## note to self, I also need to try to extract the layout of the nodes (only the variables not the interaction nodes) to try to keep them consistent, if possible. 
```


```{r}
FactorGraph(object = fit_obj3,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(testing),
pie = c(error_list3, rep(0,n_int3)),
pieBorder = c(rep(.2,7),rep(0,n_int3)),
pieColor = c(color_list3,rep(0,n_int3)),
title = "full sample - mental health as a linear moderator")

```

this network shows largely the same pattern as splitting by the high and low group. Some of the edges appear to be moderated by mental health. 


```{r, eval = FALSE}

mgm3_out <- 1:50

count2 <- 1

for(i in 1:50) {

fit_obj3 <- mgm(data = testing,
  type = c(rep("g", 7)),
  level = c(rep(1, 7)),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(1)#,
  #lambdaSel = "EBIC",
  #lambdaGam = .5
)

mgm3_out[i] <- length(fit_obj3$interactions$weightsAgg[[2]])

count2 <- count2 + 1
  
  
}

```


## This was followed by examining the stability of the network


```{r stability}
boot1 <- estimateNetwork(data = testing,
                  default = "mgm",
                   type = c(rep("g", 7)),
                   level = c(rep(1, 7)),
                   rule = "OR",
                   binarySign = TRUE,
                   moderators = c(1),
                   criterion = "CV")
 

# plot(boot1)

```

```{r centralityplot}
 
centralityPlot(boot1, labels = colnames(testing))

```

The centrality plot provides an indication of how important each variable is to the network. 

```{r bootnet}
 
boot2 <- bootnet(boot1, nBoots = 200, nCores = parallel::detectCores())
 
```

```{r edge_stability}

 plot(boot2, order = "sample")

```

This plot provides a visualisation of the bootstrapped edge strenghts of all edges

```{r }
 plot(boot2, "strength", plot = "difference")

```

I'm not 100% what this next one is just yet

```{r edge_differences}

plot(boot2, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

```

this provides an indication of all differences between edges. 

```{r centrality_bootnet}

boot3 <- bootnet(boot1, nBoots = 200, nCores = parallel::detectCores(), type = "case")

```

```{r centrality_stability}

plot(boot3)

```

plots the stability of the centrality indices, and next are the actual indices

```{r printcorestanility}
corStability(boot3)
```



```{r}



```

\newpage

# References
```{r create_r-references}
r_refs(file = "r-references.bib")
```

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id = "refs"></div>
\endgroup
