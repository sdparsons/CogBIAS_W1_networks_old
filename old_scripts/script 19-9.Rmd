---
title             : "Cognitive correlates of mental health in adolescence: A network analysis approach"
shorttitle        : "Combined Cognitive Bias Hypothesis Network"

author: 
  - name          : "Sam Parsons"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "Postal address"
    email         : "sam.parsons@psy.ox.ac.uk"
  - name          : "Annabel Songco"
    affiliation   : "1"
  - name          : "Charlotte Booth"
    affiliation   : "1"
  - name          : "Elaine Fox"
    affiliation   : "1"

affiliation:
  - id            : "1"
    institution   : "University of Oxford"


authornote: |
  Add complete departmental affiliations for each author here. Each new line herein must be indented, like this line.

  Enter author note here.

abstract: |
  This is my abstract
  
keywords          : "keywords"
wordcount         : "X"

bibliography      : ["r-references.bib"]

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : yes
mask              : no
draft             : no

documentclass     : "apa6"
classoption       : "man"
output            : papaja::apa6_pdf

header-includes: #allows you to add in your own Latex packages
- \usepackage{float} #use the 'float' package
- \floatplacement{figure}{H} #make every figure with caption = h
- \raggedbottom

---
```{r setup}
# comment in as needed
knitr::opts_chunk$set(comment = NA)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.pos= "h")
knitr::opts_chunk$set(tidy = TRUE)
knitr::opts_chunk$set(results='hide')

```

```{r load_packages, include = FALSE}
library("papaja")    # for APA formatting awesome-ness in Rmarkdown
library("tidyverse") # for restructuring data
library("foreign")   # for using SPSS data
library("bootnet")   # for network analysis
library("mgm")       # for networtk analysis
library("qgraph")    # for network analysis - specifically averageLayout
library("NetworkComparisonTest") # for network model comparisons
library("parallel") # used to get number of cores for bootnet
library("gridExtra") # used for combining plots
library("Cairo")
library("splithalf") # for internal consistency of measures
library("psych")
library("scales") # for plotting the interaction figures
library("RColorBrewer") # for plotting the interaction figures



```

```{r load_data}
# demographics, questionnaire responses, and task data all stored in separate SPSS data files.
demographics <- read.spss("Data/W1_demographics.sav", to.data.frame = TRUE)
# scores1 <- read.spss("Data/W1_Q1.sav", to.data.frame = TRUE)
scores2 <- read.spss("Data/W1_Q2.sav", to.data.frame = TRUE)
AIBQ <- read.spss("Data/W1_AIBQ.sav", to.data.frame = TRUE)
Memory <- read.spss("Data/W1_SRET.sav", to.data.frame = TRUE)
AB_raw <- read.spss("Data/Dot-Probe SPSS Start.sav", to.data.frame = TRUE)
AIBQ_raw <- read.spss("Data/Start_AIBQ_rawdata.sav", to.data.frame = TRUE)


```

```{r create dataframe for analysis}
# first extract the variables of interest
Qdat <- data.frame(subject = scores2$Master_subject,
                   MHC_Tot = scores2$MCSHC_Total)

AIBQdat <- data.frame(subjectAIBQ = AIBQ$Master_subject,
                      Pos_Soc    = AIBQ$Interpretation_Pos_Social,
                      Pos_nonsoc = AIBQ$Interpretation_Pos_Nonsocial,
                      Neg_soc    = AIBQ$Interpretation_Neg_Social,
                      Neg_nonsoc = AIBQ$Interpretation_Neg_Nonsocial)

Memdat <- data.frame(subjectMEM = Memory$Master_subject,
                     MEM_pos = Memory$PosEndorsedAndRecalled,
                     MEM_neg = Memory$NegEndorsedAndRecalled)

# combine into one dataframe
CCBH <- cbind(Qdat,AIBQdat,Memdat)

# quick checks that all IDs match
sum(isFALSE(CCBH$subject == CCBH$subjectAIBQ)) 
sum(isFALSE(CCBH$subjectQ == CCBH$subjectMEM))
sum(isFALSE(CCBH$subjectAIBQ == CCBH$subjectMEM))

# remove previous data frames to save space
remove(list = c("AIBQ", "Memory", "Qdat","AIBQdat", "Memdat"))

# remove participants with incomplete data # n=443 (with that extra participant, and DPT acc < 70% removed)
CCBH <- na.omit(CCBH)

#mean(CCBH$MHC_Tot)
#sd(CCBH$MHC_Tot)
#quantile(CCBH$MHC_Tot, c(.33, .66)) # 37 and 47

CCBH2 <- CCBH %>%
  select(2,4,5,6,7,9,10) %>%
  rename(MH = MHC_Tot,
         IB_S_Pos = Pos_Soc,
         IB_N_Pos = Pos_nonsoc,
         IB_S_Neg = Neg_soc,
         IB_N_Neg = Neg_nonsoc,
         MB_Pos = MEM_pos,
         MB_Neg = MEM_neg)

# save correlation and covariance matrices
full_cor <- cor(CCBH2)
full_cov <- cov(CCBH2)

write.csv(full_cor, "Apendices/fullsample_cor.csv")
write.csv(full_cov, "Apendices/fullsample_cov.csv")

  

```

```{r reliability stuff, results = 'hide', cache=TRUE}
# attention bias

# specific recodings
AB_raw$subject <- ifelse(AB_raw$subject == "315177", "351177", AB_raw$subject)
AB_raw$subject <- ifelse(AB_raw$subject == "316384", "361384", AB_raw$subject)
AB_raw$subject <- ifelse(AB_raw$subject == "551153", "331153", AB_raw$subject)
AB_raw$subject <- ifelse(AB_raw$subject == "319519", "391519", AB_raw$subject)

# this for the subjects that were in group 371 not 361

AB_raw2 <- AB_raw %>%
                separate(subject, sep = 3, into = c("first", "second"))
AB_raw2$first <- ifelse(AB_raw2$first == "361" & as.numeric(AB_raw2$second) >= 334 & as.numeric(AB_raw2$second) <= 440, "371", AB_raw2$first)
AB_raw2$subject <- paste(AB_raw2$first, AB_raw2$second, sep = "")  


# finally, remove data from participants that had <70 accuracy and other reasons

AB_raw2 <-   AB_raw2 %>% 
                filter(subject != 311002,
                       subject != 311019,
                       subject != 311028,
                       subject != 301036,
                       subject != 301041,
                       subject != 331126,
                       subject != 381491,
                       subject != 381441,
                       subject != 381442,
                       subject != 381443,
                       subject != 381444,
                       subject != 381478 )

AB_raw2 <- filter(AB_raw2, subject %in% unique(CCBH$subject))

# now, our participant list in the CCBH data will have the same subjects as the AB_raw2

# quick check
data.frame(name = unique(AB_raw2$subject) %in% unique(CCBH$subject),
           number = unique(AB_raw2$subject))

# need to remove those without compete dataframes so that reliability is calculated fro only the final sample


# ensuring that the blockcode only contains the actual condition
AB_raw2$blockcode <- ifelse(grepl("pain", AB_raw2$blockcode), "pain", 
                     ifelse(grepl("angry", AB_raw2$blockcode), "angry",
                     ifelse(grepl("happy", AB_raw2$blockcode), "happy", "")))

# ensuring that the congruent and incongruent labels are of the correct name fir the script
AB_raw2$congruency <- ifelse(grepl("incongruent", AB_raw2$trialcode), "Incongruent", "Congruent")

# trimming as per protocol
AB_raw2 <- AB_raw2 %>%
  group_by(subject) %>%
  filter(blockcode != "") %>%
  filter(correct == 1) %>%
  filter(latency >= 200, latency <= 3000) %>%
  group_by(subject, blockcode, congruency) %>%
  mutate(high = mean(latency)+(3*sd(latency)),
         low = mean(latency)-(3*sd(latency))) %>%
  filter(latency >= low, latency <= high) %>%
  ungroup() %>%
  as.data.frame()

AB_reliability <- splithalf(data = AB_raw2, 
                            outcome = "RT",
                            score = "difference",
                      conditionlist = c("happy", "angry", "pain"),
                      halftype = "random",
                      permutations = 5000,
                      var.RT = "latency",
                      var.condition = "blockcode",
                      var.participant = "subject", 
                      var.trialnum = "trialnum",
                      var.compare = "congruency",
                      compare1 = "Congruent",
                      compare2 = "Incongruent",
                      var.ACC = "correct")


 AB_reliability[,-2:-5]


####  AIBQ

# some renaming first
# specific recodings
AIBQ_raw$subject <- ifelse(AIBQ_raw$subject == "315177", "351177", AIBQ_raw$subject)
AIBQ_raw$subject <- ifelse(AIBQ_raw$subject == "316384", "361384", AIBQ_raw$subject)
AIBQ_raw$subject <- ifelse(AIBQ_raw$subject == "551153", "331153", AIBQ_raw$subject)
AIBQ_raw$subject <- ifelse(AIBQ_raw$subject == "319519", "391519", AIBQ_raw$subject)

# this for the subjects that were in group 371 not 361

AIBQ_raw2 <- AIBQ_raw %>%
                separate(subject, sep = 3, into = c("first", "second"))
AIBQ_raw2$first <- ifelse(AIBQ_raw2$first == "361" & as.numeric(AIBQ_raw2$second) >= 334 & as.numeric(AIBQ_raw2$second) <= 440, "371", AIBQ_raw2$first)
AIBQ_raw2$subject <- paste(AIBQ_raw2$first, AIBQ_raw2$second, sep = "")  

# finally, remove data from participants that had <70 accuracy and other reasons

# AIBQ_raw2 <-   AIBQ_raw2 %>% 
#                 filter(subject != 311002,
#                        subject != 311019,
#                        subject != 311028,
#                        subject != 301036,
#                        subject != 301041,
#                        subject != 331126,
#                        subject != 381491,
#                        subject != 381441,
#                        subject != 381442,
#                        subject != 381443,
#                        subject != 381444,
#                        subject != 381478 )

AIBQ_raw2 <- filter(AIBQ_raw2, subject %in% unique(CCBH$subject))


# checking

unique(AIBQ_raw2$subject) %in% unique(CCBH$subject)

# social positive

soc_pos <- AIBQ_raw2 %>%
  select("sit2pos_response", "sit4pos_response", "sit7pos_response", "sit9pos_response", "sit10pos_response") %>%
  psych::alpha() %>%
  capture.output()

soc_pos_o <- AIBQ_raw2 %>%
  select("sit2pos_response", "sit4pos_response", "sit7pos_response", "sit9pos_response", "sit10pos_response") %>%
  psych::omega(plot = FALSE)

# social negative

soc_neg <- AIBQ_raw2 %>%
  select("sit2neg_response", "sit4neg_response", "sit7neg_response", "sit9neg_response", "sit10neg_response") %>%
  psych::alpha() %>%
  capture.output()

soc_neg_o <- AIBQ_raw2 %>%
  select("sit2neg_response", "sit4neg_response", "sit7neg_response", "sit9neg_response", "sit10neg_response") %>%
  psych::omega(plot = FALSE)

# nonsocial positive
# 1, 3, 5, 6, 8, 

nonsoc_pos <- AIBQ_raw2 %>%
  select("sit1pos_response", "sit3pos_response", "sit5pos_response", "sit6pos_response", "sit8pos_response") %>%
  psych::alpha() %>%
  capture.output()

nonsoc_pos_o <- AIBQ_raw2 %>%
  select("sit1pos_response", "sit3pos_response", "sit5pos_response", "sit6pos_response", "sit8pos_response") %>%
  psych::omega(plot = FALSE)

# nonsocial negative

nonsoc_neg <- AIBQ_raw2 %>%
  select("sit1neg_response", "sit3neg_response", "sit5neg_response", "sit6neg_response", "sit8neg_response") %>%
  psych::alpha() %>%
  capture.output()

nonsoc_neg_o <- AIBQ_raw2 %>%
  select("sit1neg_response", "sit3neg_response", "sit5neg_response", "sit6neg_response", "sit8neg_response") %>%
  psych::omega(plot = FALSE)




AIBQ_reliability_table <- data.frame(                                     social = c("social","social","nonsocial","nonsocial"),
                                     valence = c("pos", "neg", "pos", "neg"),
                                     alphas = c(soc_pos[11],
                                                soc_neg[11],
                                                nonsoc_pos[11],
                                                nonsoc_neg[11]),
                                     omega = c(round(soc_pos_o$omega.tot,2),
                                                round(soc_neg_o$omega.tot,2),
                                                round(nonsoc_pos_o$omega.tot,2),
                                                round(nonsoc_neg_o$omega.tot,2))) %>%
                  separate(alphas, sep = " ", into = c("lower", "alpha", "upper"))




#####   reliability for the MHC

MHC_only <- select(scores2, c("Master_subject",
                              "MCSHCSQ001",
                              "MCSHCSQ002",
                              "MCSHCSQ003",
                              "MCSHCSQ004",
                              "MCSHCSQ005",
                              "MCSHCSQ006",
                              "MCSHCSQ007",
                              "MCSHCSQ008",
                              "MCSHCSQ009",
                              "MCSHCSQ010",
                              "MCSHCSQ011",
                              "MCSHCSQ012",
                              "MCSHCSQ013",
                              "MCSHCSQ014"))

MHC_only <- filter(MHC_only, Master_subject %in% unique(CCBH$subject))

# alphas for scales for each group
MHC_alpha <- MHC_only %>%
  filter(Master_subject %in% unique(CCBH$subject)) %>%
  select(-Master_subject) %>%
  psych::alpha() %>%
  capture.output()

MHC_alpha[11]

MHC_omega <- MHC_only %>%
  filter(Master_subject %in% unique(CCBH$subject)) %>%
  select(-Master_subject) %>%
  psych::omega(plot = FALSE)

MHC_omega$omega.tot


```

```{r table1, results = 'asis'}
demographics2 <- demographics %>%
  filter(MASTERNUMBER %in% unique(CCBH$subject))

m_sd <- psych::describe(CCBH2) %>%
  select(mean, sd) %>%
  round(2)

rownames(m_sd) <- c("MH (1)",
                    "IB_S_Pos (2)",
                    "IB_N_Pos (3)",
                    "IB_S_Neg (4)",
                    "IB_N_Neg (5)",
                    "MB_Pos (6)",
                    "MB_Neg (7)")

library("corrr")

fash1 <- fashion(cor(CCBH2), decimals = 2, leading_zeros = FALSE, na_print = "") %>%
  rename('(1)' = MH,
         '(2)' = IB_S_Pos,
         '(3)' = IB_N_Pos,
         '(4)' = IB_S_Neg,
         '(5)' = IB_N_Neg,
         '(6)' = MB_Pos,
         '(7)' = MB_Neg) %>%
  select(-'(7)')

fash1[upper.tri(fash1, diag = TRUE)] <- ""

papaja::apa_table(cbind(m_sd, fash1),
                  align = c('l', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r'))

```

```{r create high and low groups}
# checking sample size for the tertile split
low  <- sum(CCBH$MHC_Tot < 37) # 145
mid  <- sum(CCBH$MHC_Tot >= 37 & CCBH$MHC_Tot <= 47) # 153
high <- sum(CCBH$MHC_Tot > 47) # 150

# subsetting into three samples
low2 <- subset(CCBH, MHC_Tot < 37) # 
mid2 <- subset(CCBH, MHC_Tot >= 37 & MHC_Tot <= 47)
high2 <- subset(CCBH, MHC_Tot > 47)

low_ppt <- unique(low2$subject)
mid_ppt <- unique(mid2$subject)
high_ppt <- unique(high2$subject)


# selecting only the variables for inclusion in the networks
low3  <- low2[,c(4,5,6,7,9,10)]
mid3  <- mid2[,c(4,5,6,7,9,10)]
high3 <- high2[,c(4,5,6,7,9,10)]

# changing variable names for interpretability
variable_names  <- c("IB_S_Pos", "IB_N_Pos", "IB_S_Neg", "IB_N_Neg", "MB_Pos", "MB_Neg")
colnames(low3)  <- variable_names
colnames(mid3)  <- variable_names
colnames(high3) <- variable_names


# saving correlation and covariance matrices for the apendices. 

# low
low_cor <- cor(low3)
low_cov <- cov(low3)
high_cor <- cor(high3)
high_cov <- cov(high3)

write.csv(low_cor, "Apendices/lowMH_cor_matrix.csv")
write.csv(low_cov, "Apendices/lowMH_cov_matrix.csv")
write.csv(high_cor, "Apendices/highMH_cor_matrix.csv")
write.csv(high_cov, "Apendices/highMH_cov_matrix.csv")


```

Background:

The data are drawn from the CogBIAS longitudinal study (wave 1 only). Analysed are the DVs from the interpretation bias task, memory bias task, and mental health questionnaire. 



## Comparing groups high and low in positive mental health

Figure 1 presents regularised partial correlations amongst interpretation and memory biases. 


```{r glasso networks, results = 'hide', fig.show="hide"}
# estimate the networks
glasso_low  <- estimateNetwork(low3, default = "EBICglasso", tuning = .5)
glasso_mid  <- estimateNetwork(mid3, default = "EBICglasso", tuning = .5)
glasso_high  <- estimateNetwork(high3, default = "EBICglasso", tuning = .5)

low_glas_weights <- glasso_low$graph
colnames(low_glas_weights) <- variable_names
rownames(low_glas_weights) <- variable_names
mid_glas_weights <- glasso_mid$graph
colnames(mid_glas_weights) <- variable_names
rownames(mid_glas_weights) <- variable_names
high_glas_weights <- glasso_high$graph
colnames(high_glas_weights) <- variable_names
rownames(high_glas_weights) <- variable_names


max_glass <- max(low_glas_weights[which(low_glas_weights != 1)], mid_glas_weights[which(mid_glas_weights != 1)], high_glas_weights[which(high_glas_weights != 1)]) # returns highest weight in the three samples' correlation matrices


#write.csv(low_glas_weights, "./Apendices/low_glasso_weights.csv")
#write.csv(mid_glas_weights, "./Apendices/mid_glasso_weights.csv")
#write.csv(high_glas_weights, "./Apendices/high_glasso_weights.csv")

# # plot the three networks
 layout_common <- averageLayout(glasso_low,glasso_mid,glasso_high) # this is now the common layout for each figure
# 
# layout(t(1:3))
# plot(glasso_low, layout = layout_common, title = "low - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
# plot(glasso_mid, layout = layout_common, title = "mid - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
# plot(glasso_high, layout = layout_common, title = "high - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
# 
# # look at the global density
# sum(abs(glasso_low$graph))/2
# sum(abs(glasso_mid$graph))/2
# sum(abs(glasso_high$graph))/2

# plot the low and high sample networks
layout(t(1:2))
plot(glasso_low, layout = layout_common, title = "low - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

# save this plot

Cairo::Cairo(file="Figures/twoglasso.png", 
      type="png",
      bg = "white",
      units="in", 
      width=16, 
      height=8, 
      pointsize=12, 
      dpi=144)

layout(t(1:2))

plot(glasso_low, 
     layout = layout_common, 
     title = "low - MH plot", 
     theme = "colorblind", 
     labels = variable_names, 
     vsize = 13, 
     maximum = max_glass,
       title.cex = 2,
       label.cex = 1.1,
       border.width = 1.8)

plot(glasso_high, 
     layout = layout_common, 
     title = "high - MH plot", 
     theme = "colorblind", 
     labels = variable_names, 
     vsize = 13, 
     maximum = max_glass,
       title.cex = 2,
       label.cex = 1.1,
       border.width = 1.8)

dev.off()

layout(1)


```

```{r eval = FALSE}
# save this plot
c("Social Interpretation\nPositive",
  "Social Interpretation\nNegative",
  "NonSocial Interpretation\nPositive",
  "NonSocial Interpretation\nNegative",
  "Memory\nPositive",
  "Memory\nNegative")

Cairo::Cairo(file="Figures/twoglasso2.png", 
      type="png",
      bg = "white",
      units="in", 
      width=16, 
      height=8, 
      pointsize=12, 
      dpi=144)

layout(t(1:2))

plot(glasso_low, 
     layout = layout_common, 
     title = "Low Mental Health", 
     theme = "colorblind", 
     labels = c("IB S+","IB N+","IB S-","IB N-","MB+","MB-"),
     vsize = 18, 
     maximum = max_glass,
       title.cex = 2.2,
       label.cex = 1.1,
       border.width = 1.8)

plot(glasso_high, 
     layout = layout_common, 
     title = "High Mental Health", 
     theme = "colorblind",
     labels = c("IB S+","IB N+","IB S-","IB N-","MB+","MB-"),
#     nodeNames = c("Social Positive \n Interpretation Bias",
#                "Non-Social Positive \n Interpretation Bias",
#                "Social Negative \n Interpretation Bias",
#                "Non-Social Negative \n Interpretation Bias",
#                "Positive \n Memory Bias",
#                "Negative \n Memory Bias"), 
     vsize = 18, 
     maximum = max_glass,
       title.cex = 2.2,
       label.cex = 1.1,
       border.width = 1.8,
     legend.cex = 1.2)

dev.off()


```



```{r plotting_highlow}

layout(t(1:2))

plot(glasso_low, layout = layout_common, title = "low - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

```

### network comparisons

```{r networkcomparisontest, results='hide', cache=TRUE}
lh <- NCT(low3[,1:6], high3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
#lm <- NCT(low3[,1:6], mid3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
#mh <- NCT(mid3[,1:6], high3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
```

```{r NCT output}
lh$glstrinv.pval
lh$nwinv.pval

#lm$glstrinv.pval
#lm$nwinv.pval

#mh$glstrinv.pval
#mh$nwinv.pval
```

We compared the estimated networks using NetworkComparisonTest with 1000 iterations. Global strength in the high MH group (`r sum(abs(glasso_high$graph))/2`) differed from that in the low MH group (`r sum(abs(glasso_low$graph))/2`), _p_ = `r printp(lh$glstrinv.pval)`. There was no significant difference between global strength in the low MH group and the mid MH group (`r sum(abs(glasso_mid$graph))/2`).

\newpage


## Including Mental Health in the model

We explored the difference in models between high and low groups using the mgm package. Figure 2 presents the network including mental health as a categorical variable (only for high and low MH groups). 

Note. the shaded area of the 'pie' is the predicability of that node, i.e. the variance explained in that variable by the rest of the network. (I also need to include a more detailed explanation of why MH is different here as a categorical variable).



```{r moderatednetwork, results = 'hide', fig.show = "hide"}

fit_obj3 <- mgm(data = CCBH2,
  type = c(rep("g", 7)),
  level = c(rep(1, 7)),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(1)
  #lambdaSel = "EBIC",
  #lambdaGam = .5
)

# n interactions
n_int3 <- length(fit_obj3$interactions$weightsAgg[[2]])

# for the predictability aspect
p_obj3 <- predict(fit_obj3, CCBH2,
errorCat = c("CC","nCC","CCmarg"),
errorCon = c("R2"))

error_list3 <- list() # List for ring-segments
for(i in 1:7) error_list3[[i]] <- p_obj3$errors[i,2]
#beyondmarg <- p_obj2$errors[10,3]-p_obj2$errors[10,5]
#error_list[[10]] <- c(p_obj2$errors[10,5],beyondmarg)

color_list3 <- list() # List for Colors
for(i in 1:7) color_list3[[i]] <- "#90B4D4"
#color_list[[10]] <- c("#ffa500", "#ff4300")

# saving these for use in the text
pred_list <- data.frame(var = colnames(CCBH2),
           pred = unlist(error_list3))

pred_list[which.min(pred_list$pred),]



Cairo::Cairo(file="Figures/mgm_MHC_linear_fullsample_nosquarenodes.png", 
      type="png",
      bg = "white",
      units="in", 
      width=16, 
      height=8, 
      pointsize=12, 
      dpi=144)
qgraph(fit_obj3$pairwise$wadj * fit_obj3$pairwise$signs,
       pie = error_list3,
       layout="spring",
       labels = colnames(CCBH2),
       pieColor = color_list3,
       curveAll = TRUE, 
       curveDefault = .6,
       cut = 0, 
       labels = colnames(CCBH2),
       theme = "colorblind",
       vsize = 12,
       label.cex = 1
       )
dev.off()


```

```{r, eval = FALSE}

fit_obj3$interactions$indicator

showInteraction(object = fit_obj3,
                int = c(3,1,7))

```


this network shows largely the same pattern as splitting by the high and low group. Some of the edges appear to be moderated by mental health. 

### moderated network

```{r resampling_mgm, results = 'hide', cache=TRUE}

res_obj <- resample(object = fit_obj3,
              data = CCBH2,
              nB = 500)

```

```{r adapting plotRes to extract pairwise estimates}

# Adaptation of the plotRes code (from the mgm package) to extract the label order

quantiles <- c(.05, .95)
labels = NULL
decreasing = TRUE
cut = NULL
cex.label = .75
lwd.qtl = 2
cex.mean = .5 
cex.bg = 3.5 
axis.ticks = c(-.5, -.25, 0, .25, .5, .75, 1)
labels = colnames(CCBH2)


 # Get basic info
  dims <- dim(res_obj$bootParameters)
  p <- dims[1]
  nB <- dims[3]
  n_pars <- p*(p-1) / 2
  
  # Collapse into edge x property matrix
  tar_mat <- matrix(NA, nrow=n_pars, ncol = 6)
  colnames(tar_mat) <- c("Variable A", "Variable B", "Mean", "qtl_low", "qtl_high", "propLtZ")
  
  counter <- 1
  for(row in 1:p) {
    for(col in row:p) {
      if(row!=col){
        
        # Variable ids
        tar_mat[counter, 1] <- row
        tar_mat[counter, 2] <- col

        # Quantiles
        qtls <- quantile(res_obj$bootParameters[row, col, ], probs = quantiles)
        tar_mat[counter, 3] <- mean(res_obj$bootParameters[row, col, ])
        tar_mat[counter, 4] <- qtls[1]
        tar_mat[counter, 5] <- qtls[2]
        tar_mat[counter, 6] <- mean(abs(res_obj$bootParameters[row, col, ]) > 0) # proportion estimates > 0
        
        # update counter
        counter <- counter + 1
      }
    }
  }
  
  
  # Order
  tar_mat <- tar_mat[order(tar_mat[,3], decreasing = decreasing), ]
  
  # Subset (cut)
  if(is.null(cut)) {
    TM <- tar_mat
  } else {
    TM <- tar_mat[cut, ]
  }
  
  
    # Generate label vector
  if(is.null(labels)) {
    label_vec <- paste0(TM[, 1], " - ", TM[, 2])
  } else {
    tar_mat_label <- TM[ ,1:2]
    tar_mat_label <- apply(tar_mat_label, 1:2, as.character)
    for(i in 1:p) tar_mat_label[tar_mat_label == i] <- labels[i]
    label_vec <- paste0(tar_mat_label[, 1], " - ", tar_mat_label[, 2])
  }

```

```{r adapting plotRes to extract moderation_interaction estimates}


## extracting the interaction effects

call <- list('object' = "object",
               'data' = "data",
               'nB' = "nB",
               'blocks' = "blocks",
               'pbar' = "pbar")
  
outlist <- list('call' = call,
                  'bootParameters' = NULL,
                  'bootQuantiles' = NULL,
                  'models' = NULL,
                  "Times" = rep(NA, nB),
                  "totalTime" = NULL)

outlist$models <- res_obj$models

p <- length(fit_obj3$call$type)
    # nquantiles <- length(quantiles)
nB <- 50    
    
    ## Collect all estimates
    collect_array <- collect_array_sign <- array(0, dim = c(p, p, nB))

    #####
    quantiles <- c(0.05, .95)
        nquantiles <- length(quantiles)


    for(b in 1:nB) {

      for(i in 1:length(outlist$models[[b]]$interactions$indicator[[2]][,2])){

            collect_array[as.numeric(outlist$models[[b]]$interactions$indicator[[2]][i,2]),
                          as.numeric(outlist$models[[b]]$interactions$indicator[[2]][i,3]),
                          b] <- as.numeric(outlist$models[[b]]$interactions$weightsAgg[[2]][i])
            
          }
      
    }
   
     for(b in 1:nB) {

      for(i in 1:length(outlist$models[[b]]$interactions$indicator[[2]][,2])){

            collect_array_sign[as.numeric(outlist$models[[b]]$interactions$indicator[[2]][i,2]),
                          as.numeric(outlist$models[[b]]$interactions$indicator[[2]][i,3]),
                          b] <- as.numeric(outlist$models[[b]]$interactions$signs[[2]][i])
            
          }
      
    }     
    
    # add sign
    collect_array_wS <- collect_array
    ind_negative <- which(collect_array_sign == -1, arr.ind = TRUE)
    collect_array_wS[ind_negative] <- collect_array_wS[ind_negative] * -1
    

    
    # Compute quantiles
    quantile_array <- apply(collect_array_wS, 1:2, function(x) quantile(x, probs = quantiles))
    quantile_array_res <- array(dim = c(p, p, nquantiles))
    for(qu in 1:nquantiles) quantile_array_res[, , qu] <- quantile_array[qu, , ]
    
    outlist$bootParameters <- collect_array_wS
    outlist$bootQuantiles <- quantile_array_res

    
```

```{r for the interactions plot}

quantiles2 <- c(.05, .95)
labels2 = NULL
decreasing2 = TRUE
cut2 = NULL
cex.label2 = .75
lwd.qtl2 = 2
cex.mean2 = .5 
cex.bg2 = 3.5 
axis.ticks2 = c(-.2, 0, .2)
labels2 = colnames(CCBH2)

  # Get basic info
  dims2 <- dim(outlist$bootParameters)
  p2 <- dims2[1]
  nB2 <- dims2[3]
  n_pars2 <- p2*(p2-1) / 2
  
  # Collapse into edge x property matrix
  tar_mat2 <- matrix(NA, nrow=n_pars2, ncol = 6)
  colnames(tar_mat2) <- c("Variable A", "Variable B", "Mean", "qtl_low", "qtl_high", "propLtZ")
  
  counter2 <- 1
  for(row2 in 1:p2) {
    for(col2 in row2:p2) {
      if(row2!=col2){
        
        # Variable ids
        tar_mat2[counter2, 1] <- row2
        tar_mat2[counter2, 2] <- col2
        
        # Quantiles
        qtls2 <- quantile(outlist$bootParameters[row2, col2, ], probs = quantiles2)
        tar_mat2[counter2, 3] <- mean(outlist$bootParameters[row2, col2, ])
        tar_mat2[counter2, 4] <- qtls2[1]
        tar_mat2[counter2, 5] <- qtls2[2]
        tar_mat2[counter2, 6] <- mean(abs(outlist$bootParameters[row2, col2, ]) > 0) # proportion estimates > 0
        
        # update counter
        counter2 <- counter2 + 1
      }
    }
  }
  
  # this is where the change needs to be, the aim is to have the same order as in the first figure.
  
  # Order
  tar_mat2 <- tar_mat2[order(match(paste(tar_mat2[,1],tar_mat2[,2]), 
                                   paste(tar_mat[,1],tar_mat[,2]))
  ),]
    


  
  # Subset (cut)
  if(is.null(cut2)) {
    TM2 <- tar_mat2
  } else {
    TM2 <- tar_mat2[cut2, ]
  }
  
```

```{r output table}

# extract data from the previous 2 figures

out_table <- data.frame(edge = label_vec,
                        V1 = tar_mat[,1],
                        V2 = tar_mat[,2],
                        edge_mean = tar_mat[,3],
                        edge_low95 = tar_mat[,4],
                        edge_high95 = tar_mat[,5],
                        edge_prop = tar_mat[,6],
                        int_mean = tar_mat2[,3],
                        int_low95 = tar_mat2[,4],
                        int_high95 = tar_mat2[,5],
                        int_prop = tar_mat2[,6])

levelorder <- out_table$edge

```

```{r plotting the moderated network interactions}

cols <- c("#BF0000", "#E7A0A0FF","#FFFFFF","#ACACF1FF", "#0000D5")

# edges
edgesplot <- ggplot(data = out_table,
       aes(x = reorder(edge, edge_mean), y = edge_mean, group = 1, level = levelorder)) +
    geom_ribbon(data = out_table, aes(ymin = edge_low95, ymax = edge_high95, group = 1), fill = "grey80", alpha = .5) +
  labs(y = "edge strength") +
  coord_flip() +
  geom_hline(yintercept = 0, linetype="dashed", 
                color = "black", size= .5) +  geom_line(aes(colour = edge_mean), size = 1.5) +
  geom_point(aes(colour = edge_mean), size = 3) +
  scale_colour_gradientn(colours = cols, 
                         values = rescale(c(-.2, -.03, 0, .03, .2)),
                         limits = c(-.5, .5),
                         guide = "none") +

  theme(axis.title.y = element_blank()) +
    geom_point(colour = "white", size = 7, shape = "circle", y = .55) +
    geom_text(aes(label = sub("^(-?)0.", "\\1.", sprintf("%.2f", out_table$edge_prop)), y = .55), size = 3)
  
# interactions

intplot <- ggplot(data = out_table,
       aes(x = reorder(edge, edge_mean), y = int_mean, group = 1, level = levelorder, label = int_prop)) +
    geom_errorbar(data = out_table, aes(ymin = int_low95, ymax = int_high95, group = 1)) +
    labs(y = "interaction strength") +
  coord_flip() +
  scale_colour_gradientn(colours = muted(cols, l = 50, c = 70), 
                         values = rescale(c(-.1, -.01, 0, .01, .1)),
                         limits = c(-.2, .2),
                         guide = "none") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  geom_hline(yintercept = 0, linetype="dashed", 
                color = "black", size= .5) +
  geom_point(colour = "white", size = 7, shape = "circle") +
  geom_text(aes(label = sub("^(-?)0.", "\\1.", sprintf("%.2f", out_table$int_prop))), 
            size = 3)

Cairo::Cairo(file="Figures/edges_and_moderation.png", 
      type="png",
      bg = "white",
      units="in", 
      width=14, 
      height=8, 
      pointsize=12, 
      dpi=144)
grid.arrange(edgesplot, intplot, ncol = 2, widths = c(.6, .4))
dev.off()
####


```

```{r plot}
#grid.arrange(edgesplot, intplot, ncol = 2, widths = c(.6, .4))
```

```{r conditioning the visualisations on mental health}

# hist(scale(CCBH2$MH))

mgm_minus1 <- mgm::condition(object = fit_obj3,
               values = list("1" = -1))

mgm_ave <- mgm::condition(object = fit_obj3,
               values = list("1" = 0))

mgm_plus1 <- mgm::condition(object = fit_obj3,
               values = list("1" = 1))


max_compare = max(c(mgm_minus1$pairwise$wadj,
      mgm_ave$pairwise$wadj,
      mgm_plus1$pairwise$wadj))


Cairo::Cairo(file="Figures/compare_mod_levels.png", 
      type="png",
      bg = "white",
      units="in", 
      width=20, 
      height=10, 
      pointsize=12, 
      dpi=144)

layout(t(1:3))

qgraph(mgm_minus1$pairwise$wadj * mgm_minus1$pairwise$signs,
       directed = FALSE, 
       labels = colnames(CCBH2), 
       theme = "colorblind", 
       maximum = max_compare,
       vsize = 17,
       title = "-1SD MH",
       title.cex = 2.5,
       label.cex = 1.1,
       border.width = 2)

qgraph(mgm_ave$pairwise$wadj * mgm_ave$pairwise$signs,
       directed = FALSE, 
       labels = colnames(CCBH2), 
       theme = "colorblind", 
       maximum = max_compare,
       vsize = 17,
       title = "mean MH",
       title.cex = 2.5,
       label.cex = 1.1,
       border.width = 2)

qgraph(mgm_plus1$pairwise$wadj * mgm_plus1$pairwise$signs,
       directed = FALSE, 
       labels = colnames(CCBH2), 
       theme = "colorblind", 
       maximum = max_compare,
       vsize = 17,
       title = "+1SD MH",
       title.cex = 2.5,
       label.cex = 1.1,
       border.width = 2)

dev.off()


```




\newpage

# References
```{r create_r-references}
r_refs(file = "r-references.bib")
```

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id = "refs"></div>
\endgroup
