---
title             : "Cognitive correlates of mental health in adolescence: A network analysis approach"
shorttitle        : "Combined Cognitive Bias Hypothesis Network"

author: 
  - name          : "Sam Parsons"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "Postal address"
    email         : "sam.parsons@psy.ox.ac.uk"
  - name          : "Annabel Songco"
    affiliation   : "1"
  - name          : "Charlotte Booth"
    affiliation   : "1"
  - name          : "Elaine Fox"
    affiliation   : "1"

affiliation:
  - id            : "1"
    institution   : "University of Oxford"


authornote: |
  Add complete departmental affiliations for each author here. Each new line herein must be indented, like this line.

  Enter author note here.

abstract: |
  This is my abstract
  
keywords          : "keywords"
wordcount         : "X"

bibliography      : ["r-references.bib"]

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : yes
mask              : no
draft             : no

documentclass     : "apa6"
classoption       : "man"
output            : papaja::apa6_pdf

header-includes: #allows you to add in your own Latex packages
- \usepackage{float} #use the 'float' package
- \floatplacement{figure}{H} #make every figure with caption = h
- \raggedbottom

---
```{r setup}
# comment in as needed
knitr::opts_chunk$set(comment = NA)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.pos= "h")
knitr::opts_chunk$set(tidy = TRUE)
knitr::opts_chunk$set(results='hide')


```

```{r load_packages, include = FALSE}
library("papaja")    # for APA formatting awesome-ness in Rmarkdown
library("tidyverse") # for restructuring data
library("foreign")   # for using SPSS data
library("bootnet")   # for network analysis
library("mgm")       # for networtk analysis
library("qgraph")    # for network analysis - specifically averageLayout
library("NetworkComparisonTest") # for network model comparisons
library("parallel") # used to get number of cores for bootnet
library("gridExtra") # used for combining plots
library("Cairo")


```

```{r load_data}
# demographics, questionnaire responses, and task data all stored in separate SPSS data files.
demographics <- read.spss("Data/W1_demographics.sav", to.data.frame = TRUE)
# scores1 <- read.spss("Data/W1_Q1.sav", to.data.frame = TRUE)
scores2 <- read.spss("Data/W1_Q2.sav", to.data.frame = TRUE)
AIBQ <- read.spss("Data/W1_AIBQ.sav", to.data.frame = TRUE)
Memory <- read.spss("Data/W1_SRET.sav", to.data.frame = TRUE)
```


```{r create dataframe for analysis}
# first extract the variables of interest
Qdat <- data.frame(subject = scores2$Master_subject,
                   MHC_Tot = scores2$MCSHC_Total)

AIBQdat <- data.frame(subjectAIBQ = AIBQ$Master_subject,
                      Pos_Soc    = AIBQ$Interpretation_Pos_Social,
                      Pos_nonsoc = AIBQ$Interpretation_Pos_Nonsocial,
                      Neg_soc    = AIBQ$Interpretation_Neg_Social,
                      Neg_nonsoc = AIBQ$Interpretation_Neg_Nonsocial)

Memdat <- data.frame(subjectMEM = Memory$Master_subject,
                     MEM_pos = Memory$PosEndorsedAndRecalled,
                     MEM_neg = Memory$NegEndorsedAndRecalled)

# combine into one dataframe
CCBH <- cbind(Qdat,AIBQdat,Memdat)

# quick checks that all IDs match
sum(isFALSE(CCBH$subject == CCBH$subjectAIBQ)) 
sum(isFALSE(CCBH$subjectQ == CCBH$subjectMEM))
sum(isFALSE(CCBH$subjectAIBQ == CCBH$subjectMEM))

# remove previous data frames to save space
remove(list = c("AIBQ", "Memory", "Qdat","AIBQdat", "Memdat"))

# remove participants with incomplete data # n=443 (with that extra participant, and DPT acc < 70% removed)
CCBH <- na.omit(CCBH)

mean(CCBH$MHC_Tot)
sd(CCBH$MHC_Tot)
quantile(CCBH$MHC_Tot, c(.33, .66)) # 37 and 47

```

```{r create high and low groups}
# checking sample size for the tertile split
low  <- sum(CCBH$MHC_Tot < 37) # 145
mid  <- sum(CCBH$MHC_Tot >= 37 & CCBH$MHC_Tot <= 47) # 153
high <- sum(CCBH$MHC_Tot > 47) # 150

# subsetting into three samples
low2 <- subset(CCBH, MHC_Tot < 37) # 
mid2 <- subset(CCBH, MHC_Tot >= 37 & MHC_Tot <= 47)
high2 <- subset(CCBH, MHC_Tot > 47)

low_ppt <- unique(low2$subject)
mid_ppt <- unique(mid2$subject)
high_ppt <- unique(high2$subject)


# selecting only the variables for inclusion in the networks
low3  <- low2[,c(4,5,6,7,9,10)]
mid3  <- mid2[,c(4,5,6,7,9,10)]
high3 <- high2[,c(4,5,6,7,9,10)]

# changing variable names for interpretability
variable_names  <- c("IB_S_Pos", "IB_N_Pos", "IB_S_Neg", "IB_N_Neg", "MB_Pos", "MB_Neg")
colnames(low3)  <- variable_names
colnames(mid3)  <- variable_names
colnames(high3) <- variable_names

```

Background:

The data are drawn from the CogBIAS longitudinal study (wave 1 only). Analysed are the DVs from the interpretation bias task, memory bias task, and mental health questionnaire. 



## Comparing groups high and low in positive mental health

Figure 1 presents regularised partial correlations amongst interpretation and memory biases. 


```{r glasso networks, results = 'hide', fig.show="hide"}
# estimate the networks
glasso_low  <- estimateNetwork(low3, default = "EBICglasso", tuning = .5)
glasso_mid  <- estimateNetwork(mid3, default = "EBICglasso", tuning = .5)
glasso_high  <- estimateNetwork(high3, default = "EBICglasso", tuning = .5)

low_glas_weights <- glasso_low$graph
colnames(low_glas_weights) <- variable_names
rownames(low_glas_weights) <- variable_names
mid_glas_weights <- glasso_mid$graph
colnames(mid_glas_weights) <- variable_names
rownames(mid_glas_weights) <- variable_names
high_glas_weights <- glasso_high$graph
colnames(high_glas_weights) <- variable_names
rownames(high_glas_weights) <- variable_names


max_glass <- max(low_glas_weights[which(low_glas_weights != 1)], mid_glas_weights[which(mid_glas_weights != 1)], high_glas_weights[which(high_glas_weights != 1)]) # returns highest weight in the three samples' correlation matrices


write.csv(low_glas_weights, "./Apendices/low_glasso_weights.csv")
write.csv(mid_glas_weights, "./Apendices/mid_glasso_weights.csv")
write.csv(high_glas_weights, "./Apendices/high_glasso_weights.csv")

# plot the three networks
layout_common <- averageLayout(glasso_low,glasso_mid,glasso_high) # this is now the common layout for each figure

layout(t(1:3))
plot(glasso_low, layout = layout_common, title = "low - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_mid, layout = layout_common, title = "mid - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

# look at the global density
sum(abs(glasso_low$graph))/2
sum(abs(glasso_mid$graph))/2
sum(abs(glasso_high$graph))/2

# plot the low and high sample networks
layout(t(1:2))
plot(glasso_low, layout = layout_common, title = "low - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

# save this plot

Cairo::Cairo(file="Figures/twoglasso.png", 
      type="png",
      bg = "white",
      units="in", 
      width=16, 
      height=8, 
      pointsize=12, 
      dpi=144)
layout(t(1:2))

plot(glasso_low, layout = layout_common, title = "low - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

dev.off()


```

```{r plotting_highlow}

layout(t(1:2))

plot(glasso_low, layout = layout_common, title = "low - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)
plot(glasso_high, layout = layout_common, title = "high - MH plot", details = T, theme = "colorblind", labels = variable_names, vsize = 10, maximum = max_glass)

```

### network comparisons

```{r networkcomparisontest, results='hide'}
lh <- NCT(low3[,1:6], high3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
lm <- NCT(low3[,1:6], mid3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
mh <- NCT(mid3[,1:6], high3[,1:6], it=1000, gamma = .5, binary.data=FALSE)
```

```{r}
lh$glstrinv.pval
lh$nwinv.pval

lm$glstrinv.pval
lm$nwinv.pval

mh$glstrinv.pval
mh$nwinv.pval
```

We compared the estimated networks using NetworkComparisonTest with 1000 iterations. Global strength in the high MH group (`r sum(abs(glasso_high$graph))/2`) differed from that in the low MH group (`r sum(abs(glasso_low$graph))/2`), _p_ = `r printp(lh$glstrinv.pval)`. There was no significant difference between global strength in the low MH group and the mid MH group (`r sum(abs(glasso_mid$graph))/2`), _p_ = `r printp(lm$glstrinv.pval)`; nor between the mid MH and high MH groups, _p_ = `r printp(mh$glstrinv.pval)`.

\newpage


```{r trying to figure out optimalgraph, eval=FALSE}

modSelect_0 <- ggmModSelect(cor_auto(low3), nrow(low3), nCores = 12, start = "glasso", considerPerStep = "all", gamma = 0)

qgraph(modSelect_0$graph, layout = "spring", theme = "colorblind", 
       title = "ggmModSelect (gamma = 0)", cut = 0)

modSelect_0.5 <- ggmModSelect(cor_auto(low3), nrow(low3), gamma = 0.5, nCores = 12, start = "glasso", considerPerStep = "all")

qgraph(modSelect_0.5$graph, layout = "spring", theme = "colorblind", 
       title = "ggmModSelect (gamma = 0)", cut = 0)

```

## Including Mental Health in the model

We explored the difference in models between high and low groups using the mgm package. Figure 2 presents the network including mental health as a categorical variable (only for high and low MH groups). 

Note. the shaded area of the 'pie' is the predicability of that node, i.e. the variance explained in that variable by the rest of the network. (I also need to include a more detailed explanation of why MH is different here as a categorical variable).

```{r mgm, results='hide'}
# this block includes MH as a categorical variable and includes it in mgm, also returns predictability indices. 

# put low and high group into a single dataframe
low3$MH <- 0
high3$MH <- 1

full <- rbind(low3, high3)

fit_obj <- mgm(data = full,
  type = c(rep("g", 6), "c"),
  level = c(rep(1, 6), 2),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE)



p_obj <- predict(fit_obj, full,
errorCat = c("CC","nCC","CCmarg"),
errorCon = c("R2"))


error_list <- list() # List for ring-segments
for(i in 1:6) error_list[[i]] <- p_obj$errors[i,2]
beyondmarg <- p_obj$errors[7,3]-p_obj$errors[7,5]
error_list[[7]] <- c(p_obj$errors[7,5],beyondmarg)

color_list <- list() # List for Colors
for(i in 1:6) color_list[[i]] <- "#90B4D4"
color_list[[7]] <- c("#ffa500", "#ff4300")

Cairo::Cairo(file="Figures/mgm_MH_categorical.png", 
      type="png",
      bg = "white",
      units="in", 
      width=10, 
      height=8, 
      pointsize=12, 
      dpi=144)
qgraph(fit_obj$pairwise$wadj, pie = error_list,
  layout="spring", labels = colnames(full),
  pieColor = color_list, label.cex = .9,
  edge.color = fit_obj$pairwise$edgecolor,
  curveAll = TRUE, curveDefault = .6,
  cut = 0, labels = col(full))
dev.off()

```

## we then set mental health to be a moderator of the network

```{r, results='hide', fig.show = "hide"}
fit_obj2 <- mgm(data = full,
  type = c(rep("g", 6), "c"),
  level = c(rep(1, 6), 2),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(7),
  lambdaFolds = 10,
  alphaFolds = 10
  #,
  #lambdaSel = "EBIC",   #possible alternatives
  #lambdaGam = .25
)

# n interactions
n_int <- length(fit_obj2$interactions$weightsAgg[[2]])

# for the predictability aspect
p_obj2 <- predict(fit_obj2, full,
errorCat = c("CC","nCC","CCmarg"),
errorCon = c("R2"))


error_list2 <- list() # List for ring-segments
for(i in 1:6) error_list2[[i]] <- p_obj2$errors[i,2]
beyondmarg2 <- p_obj2$errors[7,3]-p_obj2$errors[7,5]
error_list2[[7]] <- c(p_obj2$errors[7,5],beyondmarg2)

color_list2 <- list() # List for Colors
for(i in 1:6) color_list2[[i]] <- "#90B4D4"
color_list2[[7]] <- c("#ffa500", "#ff4300")

# plotting predictability
qgraph(fit_obj2$pairwise$wadj, pie = error_list2,
  layout="spring", labels = colnames(full),
  pieColor = color_list2, label.cex = .9,
  edge.color = fit_obj2$pairwise$edgecolor,
  curveAll = TRUE, curveDefault = .6,
  cut = 0, labels = col(full))

# plotting the interactions
FactorGraph(object = fit_obj2,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(full),
title = "fit2 with interactions")


# #playing
# FactorGraph(object = fit_obj2,
# edge.labels = FALSE,
# PairwiseAsEdge = TRUE,
# FactorLabels = TRUE,
# Nodewise = TRUE, 
# labels = colnames(full))

# plotting the interactions and the predictability
img <- FactorGraph(object = fit_obj2,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(full),
pie = c(error_list2, rep(0,n_int)),
pieBorder = c(rep(.2,7),rep(0,n_int)),
pieColor = c(color_list2,rep(0,n_int)))

# could add these for prettiness
#vsize = 2,
#vsize2 = .5,
#label.cex = 1,
#repulsion = .63)


# quick save

Cairo::Cairo(file="Figures/mgmtest.png", 
      type="png",
      bg = "white",
      units="in", 
      width=12, 
      height=8, 
      pointsize=12, 
      dpi=144)

FactorGraph(object = fit_obj2,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(full),
pie = c(error_list2, rep(0,n_int)),
pieBorder = c(rep(.2,7),rep(0,n_int)),
pieColor = c(color_list2,rep(0,n_int)),
vsize = 2,
vsize2 = .5,
label.cex = 1,
repulsion = .63)

dev.off()


```

```{r }
FactorGraph(object = fit_obj2,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(full),
pie = c(error_list2, rep(0,n_int)),
pieBorder = c(rep(.2,7),rep(0,n_int)),
pieColor = c(color_list2,rep(0,n_int)),
title = "MH as a categorical variable in the model")

```


The square nodes link to three nodes. First, they each link to MH as the moderating variable. The two other nodes linked to indicate the edge that is moderated by the MH variable, e.g. the relationship between Positive and Negative memory biases. 


```{r checknumberofmoderatededges, eval = FALSE}

mod_list <- rep(1, 50)
count <- 1

for(i in 1:50) {

fit_obj2 <- mgm(data = full,
  type = c(rep("g", 6), "c"),
  level = c(rep(1, 6), 2),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(7),
  lambdaFolds = 50,
  alphaFolds = 50
  #,
  #lambdaSel = "EBIC",   #possible alternatives
  #lambdaGam = .25
)

# n interactions
mod_list[i] <- length(fit_obj2$interactions$weightsAgg[[2]])

count <- count + 1
}
mean(mod_list)
min(mod_list)
max(mod_list)


```


## we followed this by using MH as a linear moderator, and included the full sample


```{r, results='hide', fig.show="hide"}

testing <- CCBH %>%
  select(2,4,5,6,7,9,10) %>%
  rename(MH = MHC_Tot,
         IB_S_Pos = Pos_Soc,
         IB_N_Pos = Pos_nonsoc,
         IB_S_Neg = Neg_soc,
         IB_N_Neg = Neg_nonsoc,
         MB_Pos = MEM_pos,
         MB_Neg = MEM_neg)
  

fit_obj3 <- mgm(data = testing,
  type = c(rep("g", 7)),
  level = c(rep(1, 7)),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(1)
  #lambdaSel = "EBIC",
  #lambdaGam = .5
)

# n interactions
n_int3 <- length(fit_obj3$interactions$weightsAgg[[2]])

# for the predictability aspect
p_obj3 <- predict(fit_obj3, testing,
errorCat = c("CC","nCC","CCmarg"),
errorCon = c("R2"))


error_list3 <- list() # List for ring-segments
for(i in 1:7) error_list3[[i]] <- p_obj3$errors[i,2]
#beyondmarg <- p_obj2$errors[10,3]-p_obj2$errors[10,5]
#error_list[[10]] <- c(p_obj2$errors[10,5],beyondmarg)

color_list3 <- list() # List for Colors
for(i in 1:7) color_list3[[i]] <- "#90B4D4"
#color_list[[10]] <- c("#ffa500", "#ff4300")

# plotting predictability
plot1 <- qgraph(fit_obj3$pairwise$wadj, pie = error_list3,
  layout="spring", labels = colnames(testing),
  pieColor = color_list3, label.cex = .9,
  edge.color = fit_obj3$pairwise$edgecolor,
  curveAll = TRUE, curveDefault = .6,
  cut = 0, labels = colnames(testing),
  title = "MGM plot")

Cairo::Cairo(file="Figures/mgm_MHC_linear_fullsample_nosquarenodes.png", 
      type="png",
      bg = "white",
      units="in", 
      width=16, 
      height=8, 
      pointsize=12, 
      dpi=144)
qgraph(fit_obj3$pairwise$wadj, pie = error_list3,
  layout="spring", labels = colnames(testing),
  pieColor = color_list3, label.cex = .9,
  edge.color = fit_obj3$pairwise$edgecolor,
  curveAll = TRUE, curveDefault = .6,
  cut = 0, labels = colnames(testing),
  title = "MGM plot")
dev.off()


# plotting the interactions


FactorGraph(object = fit_obj3,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(testing),
title = "full sample - mental health as a linear moderator")




 ## note to self, I also need to try to extract the layout of the nodes (only the variables not the interaction nodes) to try to keep them consistent, if possible. 
```


```{r}
Cairo::Cairo(file="Figures/mgm_MHC_linear_fullsample.png", 
      type="png",
      bg = "white",
      units="in", 
      width=16, 
      height=8, 
      pointsize=12, 
      dpi=144)
FactorGraph(object = fit_obj3,
edge.labels = FALSE,
PairwiseAsEdge = TRUE,
labels = colnames(testing),
pie = c(error_list3, rep(0,n_int3)),
pieBorder = c(rep(.2,7),rep(0,n_int3)),
pieColor = c(color_list3,rep(0,n_int3)),
title = "full sample - mental health as a linear moderator")
dev.off()

```

this network shows largely the same pattern as splitting by the high and low group. Some of the edges appear to be moderated by mental health. 


```{r, eval = FALSE}

mgm3_out <- 1:200

count2 <- 1

for(i in 1:200) {

fit_obj3 <- mgm(data = testing,
  type = c(rep("g", 7)),
  level = c(rep(1, 7)),
  ruleReg = "OR",
  k = 2,
  binarySign = TRUE,
  moderators = c(1)#,
  #lambdaSel = "EBIC",
  #lambdaGam = .5
)

mgm3_out[i] <- length(fit_obj3$interactions$weightsAgg[[2]])

count2 <- count2 + 1
  
  
}

mgm3_out
hist(mgm3_out)


```


## This was followed by examining the stability of the network


```{r stability}
boot1 <- estimateNetwork(data = testing,
                  default = "mgm",
                   type = c(rep("g", 7)),
                   level = c(rep(1, 7)),
                   rule = "OR",
                   binarySign = TRUE,
                   moderators = c(1),
                   criterion = "CV")
 

# plot(boot1)

```

```{r centralityplot}
 
centralityPlot(boot1, labels = colnames(testing))

```


The centrality plot provides an indication of how important each variable is to the network. 

```{r bootnet}
 
boot2 <- bootnet(boot1, nBoots = 200, nCores = parallel::detectCores())
 
```

```{r edge_stability}

 plot(boot2, order = "sample", plot = "area")

```

This plot provides a visualisation of the bootstrapped edge strenghts of all edges

```{r }
 plot(boot2, "strength", plot = "difference")

```

I'm not 100% what this next one is just yet

```{r edge_differences}

plot(boot2, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")

```

this provides an indication of all differences between edges. 

```{r centrality_bootnet}

boot3 <- bootnet(boot1, nBoots = 200, nCores = parallel::detectCores(), type = "case")

```

```{r centrality_stability}

plot(boot3)

```

plots the stability of the centrality indices, and next are the actual indices

```{r printcorestanility}
corStability(boot3)
```



```{r resampling}

res_obj <- resample(object = fit_obj3,
              data = testing,
              nB = 500)

```

```{r plotRes}

# Adaptation of the plotRes code to extract the label order

quantiles <- c(.05, .95)
labels = NULL
decreasing = TRUE
cut = NULL
cex.label = .75
lwd.qtl = 2
cex.mean = .5 
cex.bg = 3.5 
axis.ticks = c(-.5, -.25, 0, .25, .5, .75, 1)
labels = colnames(testing)


 # Get basic info
  dims <- dim(res_obj$bootParameters)
  p <- dims[1]
  nB <- dims[3]
  n_pars <- p*(p-1) / 2
  
  # Collapse into edge x property matrix
  tar_mat <- matrix(NA, nrow=n_pars, ncol = 6)
  colnames(tar_mat) <- c("Variable A", "Variable B", "Mean", "qtl_low", "qtl_high", "propLtZ")
  
  counter <- 1
  for(row in 1:p) {
    for(col in row:p) {
      if(row!=col){
        
        # Variable ids
        tar_mat[counter, 1] <- row
        tar_mat[counter, 2] <- col

        # Quantiles
        qtls <- quantile(res_obj$bootParameters[row, col, ], probs = quantiles)
        tar_mat[counter, 3] <- mean(res_obj$bootParameters[row, col, ])
        tar_mat[counter, 4] <- qtls[1]
        tar_mat[counter, 5] <- qtls[2]
        tar_mat[counter, 6] <- mean(abs(res_obj$bootParameters[row, col, ]) > 0) # proportion estimates > 0
        
        # update counter
        counter <- counter + 1
      }
    }
  }
  
  
  # Order
  tar_mat <- tar_mat[order(tar_mat[,3], decreasing = decreasing), ]
  
  # Subset (cut)
  if(is.null(cut)) {
    TM <- tar_mat
  } else {
    TM <- tar_mat[cut, ]
  }
  
  # ---------- Plotting ----------  
  
  # Compute aux variables for plotting
  n_rows <- nrow(TM)

  ylim <- c(0, 1)
  plot_y <- seq(ylim[2], ylim[1], length = n_rows)
  mar <- c(0, .5, 3, .5)
  
  # ----- Setup layout ----
  
  lmat <- matrix(1:2, nrow=1)
  lo <- layout(lmat, widths = c(.2, 1))
  
  # ----- Part A: Legend ----
  
  # Generate label vector
  if(is.null(labels)) {
    label_vec <- paste0(TM[, 1], " - ", TM[, 2])
  } else {
    tar_mat_label <- TM[ ,1:2]
    tar_mat_label <- apply(tar_mat_label, 1:2, as.character)
    for(i in 1:p) tar_mat_label[tar_mat_label == i] <- labels[i]
    label_vec <- paste0(tar_mat_label[, 1], " - ", tar_mat_label[, 2])
  }
  
  # Plot  
  par(mar=mar)
  plot.new()
  plot.window(xlim = c(-1, 1), ylim = ylim)
  text(0, plot_y, label_vec, cex = cex.label)
  
  
  # ----- Part B: Data ----
  
  # Some settings  
  xlim <- range(axis.ticks)
  
  # Setup canvas
  par(mar=mar)
  plot.new()
  plot.window(xlim = xlim, ylim = ylim)
  if(is.null(axis.ticks)) axis.ticks <- round(seq(xlim[1], xlim[2], length = 5), 2)
  axis(3, axis.ticks, lwd=0)

  abline(h = plot_y, col = "grey")
  if(0 %in% axis.ticks) abline(v = 0, lty=2, col = "black") # zero line

  # Plot quantiles
  segments(x0 = TM[, 4], 
           y0 = plot_y, 
           x1 = TM[, 5],
           y1 = plot_y, lwd = lwd.qtl)
  
  # Plot prop>0
  points(TM[, 3], plot_y, pch=20, col="white", cex = cex.bg)
  text(TM[, 3], plot_y, TM[, 6], cex = cex.mean)



# plotRes(res_obj,
#         quantiles = c(.05, .95),
#         labels = colnames(testing))

```

```{r}


## extracting the interaction effects

call <- list('object' = "object",
               'data' = "data",
               'nB' = "nB",
               'blocks' = "blocks",
               'pbar' = "pbar")
  
outlist <- list('call' = call,
                  'bootParameters' = NULL,
                  'bootQuantiles' = NULL,
                  'models' = NULL,
                  "Times" = rep(NA, nB),
                  "totalTime" = NULL)

outlist$models <- res_obj$models

p <- length(fit_obj3$call$type)
    # nquantiles <- length(quantiles)
nB <- 50    
    
    ## Collect all estimates
    collect_array <- collect_array_sign <- array(0, dim = c(p, p, nB))

    #####
    quantiles <- c(0.05, .95)
        nquantiles <- length(quantiles)


    for(b in 1:nB) {

      for(i in 1:length(outlist$models[[b]]$interactions$indicator[[2]][,2])){

            collect_array[as.numeric(outlist$models[[b]]$interactions$indicator[[2]][i,2]),
                          as.numeric(outlist$models[[b]]$interactions$indicator[[2]][i,3]),
                          b] <- as.numeric(outlist$models[[b]]$interactions$weightsAgg[[2]][i])
            
          }
      
    }
   
     for(b in 1:nB) {

      for(i in 1:length(outlist$models[[b]]$interactions$indicator[[2]][,2])){

            collect_array_sign[as.numeric(outlist$models[[b]]$interactions$indicator[[2]][i,2]),
                          as.numeric(outlist$models[[b]]$interactions$indicator[[2]][i,3]),
                          b] <- as.numeric(outlist$models[[b]]$interactions$signs[[2]][i])
            
          }
      
    }     
    
    # add sign
    collect_array_wS <- collect_array
    ind_negative <- which(collect_array_sign == -1, arr.ind = TRUE)
    collect_array_wS[ind_negative] <- collect_array_wS[ind_negative] * -1
    

    
    # Compute quantiles
    quantile_array <- apply(collect_array_wS, 1:2, function(x) quantile(x, probs = quantiles))
    quantile_array_res <- array(dim = c(p, p, nquantiles))
    for(qu in 1:nquantiles) quantile_array_res[, , qu] <- quantile_array[qu, , ]
    
    outlist$bootParameters <- collect_array_wS
    outlist$bootQuantiles <- quantile_array_res

    
```

```{r for the interactions plot}

quantiles2 <- c(.05, .95)
labels2 = NULL
decreasing2 = TRUE
cut2 = NULL
cex.label2 = .75
lwd.qtl2 = 2
cex.mean2 = .5 
cex.bg2 = 3.5 
axis.ticks2 = c(-.2, 0, .2)
labels2 = colnames(testing)

  # Get basic info
  dims2 <- dim(outlist$bootParameters)
  p2 <- dims2[1]
  nB2 <- dims2[3]
  n_pars2 <- p2*(p2-1) / 2
  
  # Collapse into edge x property matrix
  tar_mat2 <- matrix(NA, nrow=n_pars2, ncol = 6)
  colnames(tar_mat2) <- c("Variable A", "Variable B", "Mean", "qtl_low", "qtl_high", "propLtZ")
  
  counter2 <- 1
  for(row2 in 1:p2) {
    for(col2 in row2:p2) {
      if(row2!=col2){
        
        # Variable ids
        tar_mat2[counter2, 1] <- row2
        tar_mat2[counter2, 2] <- col2
        
        # Quantiles
        qtls2 <- quantile(outlist$bootParameters[row2, col2, ], probs = quantiles2)
        tar_mat2[counter2, 3] <- mean(outlist$bootParameters[row2, col2, ])
        tar_mat2[counter2, 4] <- qtls2[1]
        tar_mat2[counter2, 5] <- qtls2[2]
        tar_mat2[counter2, 6] <- mean(abs(outlist$bootParameters[row2, col2, ]) > 0) # proportion estimates > 0
        
        # update counter
        counter2 <- counter2 + 1
      }
    }
  }
  
  # this is where the change needs to be, the aim is to have the same order as in the first figure.
  
  # Order
  tar_mat2 <- tar_mat2[order(match(paste(tar_mat2[,1],tar_mat2[,2]), 
                                   paste(tar_mat[,1],tar_mat[,2]))
  ),]
    


  
  # Subset (cut)
  if(is.null(cut2)) {
    TM2 <- tar_mat2
  } else {
    TM2 <- tar_mat2[cut2, ]
  }
  
  # ---------- Plotting ----------  
  
  # Compute aux variables for plotting
  n_rows2 <- nrow(TM2)
  
  ylim2 <- c(0, 1)
  plot_y2 <- seq(ylim2[2], ylim2[1], length = n_rows2)
  mar2 <- c(0, .5, 3, .5)
  
  # ----- Setup layout ----
  
  lmat2 <- matrix(1:2, nrow=1)
  lo2 <- layout(lmat2, widths = c(.2, 1))
  
  # ----- Part A: Legend ----
  
  # Generate label vector
  if(is.null(labels2)) {
    label_vec2 <- paste0(TM2[, 1], " - ", TM2[, 2])
  } else {
    tar_mat_label2 <- TM2[ ,1:2]
    tar_mat_label2 <- apply(tar_mat_label2, 1:2, as.character)
    for(i in 1:p) tar_mat_label2[tar_mat_label2 == i] <- labels2[i]
    label_vec2 <- paste0(tar_mat_label2[, 1], " - ", tar_mat_label2[, 2])
  }
  
  # Plot  
  par(mar=mar2)
  plot.new()
  plot.window(xlim = c(-1, 1), ylim = ylim2)
  text(0, plot_y2, label_vec2, cex = cex.label2)
  
  
  # ----- Part B: Data ----
  
  # Some settings  
  xlim2 <- range(axis.ticks2)
  
  # Setup canvas
  par(mar=mar2)
  plot.new()
  plot.window(xlim = xlim2, ylim = ylim2)
  if(is.null(axis.ticks2)) axis.ticks2 <- round(seq(xlim2[1], xlim2[2], length = 5), 2)
  axis(3, axis.ticks2, lwd=0)
  
  abline(h = plot_y, col = "grey")
  if(0 %in% axis.ticks2) abline(v = 0, lty=2, col = "black") # zero line
  
  # Plot quantiles
  segments(x0 = TM2[, 4], 
           y0 = plot_y2, 
           x1 = TM2[, 5],
           y1 = plot_y2, lwd = lwd.qtl2)
  
  # Plot prop>0
  points(TM2[, 3], plot_y2, pch=20, col="white", cex = cex.bg2)
  text(TM2[, 3], plot_y2, TM2[, 6], cex = cex.mean2)    

  
  
```

```{r}
 #    
 # plot1 <-  plotRes_alt(outlist,
 #            quantiles = c(.05,.95),
 #            axis.ticks = c(-.2, 0, .2),
 #            labels = colnames(testing),
 #            previous_order = TRUE)
 #    
 #    
```

```{r output table}

out_table <- data.frame(edge = label_vec,
                        V1 = tar_mat[,1],
                        V1 = tar_mat[,2],
                        edge_mean = tar_mat[,3],
                        edge_low95 = tar_mat[,4],
                        edge_high95 = tar_mat[,5],
                        edge_prop = tar_mat[,6],
                        int_mean = tar_mat2[,3],
                        int_low95 = tar_mat2[,4],
                        int_high95 = tar_mat2[,5],
                        int_prop = tar_mat2[,6])


```



```{r}
library("scales")

levelorder <- out_table$edge

library(RColorBrewer)

cols <- brewer.pal(n = 5, name = "RdBu") 
display.brewer.pal(n = 5, name = "RdBu")


# edges
edgesplot <- ggplot(data = out_table,
       aes(x = reorder(edge, edge_mean), y = edge_mean, group = 1, level = levelorder)) +
    geom_ribbon(data = out_table, aes(ymin = edge_low95, ymax = edge_high95, group = 1), fill = "grey80", alpha = .5) +
  coord_flip() +
  geom_line(aes(colour = edge_mean), size = 1.5) +
  geom_point(aes(colour = edge_mean), size = 3) +
  scale_colour_gradientn(colours = muted(cols, l = 50, c = 70), 
                         values = rescale(c(-.3, -.01, 0, .01, .3)),
                         limits = c(-.5, .5),
                         guide = "none") +
  geom_hline(yintercept = 0, linetype="dashed", 
                color = "black", size= .5) +
  theme(axis.title.y = element_blank()) +
    geom_point(colour = "white", size = 7, shape = "circle", y = .55) +
    geom_text(aes(label = sub("^(-?)0.", "\\1.", sprintf("%.2f", out_table$edge_prop)), y = .55), size = 3)
  
  
# interactions

intplot <- ggplot(data = out_table,
       aes(x = reorder(edge, edge_mean), y = int_mean, group = 1, level = levelorder, label = int_prop)) +
    geom_errorbar(data = out_table, aes(ymin = int_low95, ymax = int_high95, group = 1)) +
  coord_flip() +
  scale_colour_gradientn(colours = muted(cols, l = 50, c = 70), 
                         values = rescale(c(-.1, -.01, 0, .01, .1)),
                         limits = c(-.2, .2),
                         guide = "none") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  geom_hline(yintercept = 0, linetype="dashed", 
                color = "black", size= .5) +
  geom_point(colour = "white", size = 7, shape = "circle") +
  geom_text(aes(label = sub("^(-?)0.", "\\1.", sprintf("%.2f", out_table$int_prop))), 
            size = 3)

Cairo::Cairo(file="Figures/edges_and_moderation.png", 
      type="png",
      bg = "white",
      units="in", 
      width=14, 
      height=8, 
      pointsize=12, 
      dpi=144)
grid.arrange(edgesplot, intplot, ncol = 2, widths = c(.6, .4))
dev.off()
####




# ggplot(data = out_table,
#        aes(x = reorder(edge, edge_mean), y = int_mean, group = 1, level = levelorder)) +
#     geom_ribbon(data = out_table, aes(ymin = int_low95, ymax = int_high95, group = 1), fill = "grey80", alpha = .5) +
#   coord_flip() +
#   geom_line(colour = "darkred") +
#   geom_point(colour = "darkred") 




```

```{r}
# presenting the networks with different values of the moderator


out_table2 <- out_table

out_table2$minMH <- out_table$edge_mean + (out_table$int_mean * -sd(CCBH$MHC_Tot))
out_table2$maxMH <- out_table$edge_mean + (out_table$int_mean * sd(CCBH$MHC_Tot))

out_table2 %>%
  select(edge, minMH, edge_mean, maxMH) %>%
  gather(key = "mod",
         value = "edge_str",
         -edge) %>%
  ggplot(data = .,
       aes(x = reorder(edge, edge_str), y = edge_str, group = mod, colour = mod)) +
  geom_point(aes(group = mod), size = 3) +
#  geom_line(aes(group = mod), size = 1.5) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype="dashed", 
                color = "black", size= .5) 


# to plot the networks themselves differently


averageNet <- matrix(0, 7,7)

for(row in 1:7) {
  for(col in row:7) {
    if(row!=col) {
    averageNet[row,col] <- mean(res_obj$bootParameters[row,col,])
    }
  }
}

interactionNet <- matrix(0, 7,7)

for(row in 1:7) {
  for(col in 1:7) {
    interactionNet[row,col] <- mean(outlist$bootParameters[row,col,])
  }
}

layout(t(1:3))

qgraph(averageNet + (-5 * interactionNet), directed = FALSE, labels = colnames(testing))
qgraph(averageNet + (0 * interactionNet), directed = FALSE, labels = colnames(testing))
qgraph(averageNet + (5 * interactionNet), directed = FALSE, labels = colnames(testing))


```









\newpage

# References
```{r create_r-references}
r_refs(file = "r-references.bib")
```

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id = "refs"></div>
\endgroup
